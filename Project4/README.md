### 实验内容：
do your best to optimize SM3 implementation (software)
### 理论基础：
一般对于程序性能的优化，可以采取以下几种常见方式：

(1)减少循环结构，对其进行循环展开等操作

(2)利用存储结构的局部性，时间局部性和空间局部性，减少对数组的存取操作等；利用并行性，SIMD、数据流等方法。

##### 对于具体的SM3算法，可以通过分析其算法结构，有针对性的进行优化：消息扩展部分、压缩函数部分等关键部件。
### 实验思路：
本次实验采取对已有的SM3算法进行优化，通过对同样数据量的时间消耗测量显示优化结果。

##### 优化点1：消息扩展

消息扩展的目的是利用512比特的消息分组B扩展得到68个字W0,…,W67和64个字W′0,…,W′63，可以对其进行简化：

(1)首先在执行64轮压缩函数前只计算初始的4个字W0,…,W3；

(2)然后在压缩函数的第i轮生成Wi+4，而W′i则使用W′i=Wi⊕Wi+4代替。经过这样的调整，去掉了字W′0,…,W′63，减少了字W0,…,W67和W′0,…,W′63的加载和存储次数，提高了消息扩展的速度。
##### 优化点2：压缩函数
(1)压缩函数的结构可以做适当的调整。压缩函数每一轮的最末会执行如下所示的循环右移，A‖B‖C‖D←(A‖B‖C‖D)>>>32,E‖F‖G‖H←(E‖F‖G‖H)>>>32。为了减少循环移位导致的不必要的赋值运算，可以将字的循环右移变更每轮输入字顺序的变动，且这个顺序变动会在4轮后还原。

(2)可以优化压缩函数的中间变量的生成流程。此优化生成流程可以去除不必要的赋值，减少中间变量个数。

(3)预先计算并存储常数ti=Ti<<<i。这可以避免每个消息分组都去计算常数，且占用的存储空间也很少，仅256 Byte。
##### 优化点3：循环展开及利用局部变量代替数组访问
将类似：
```c
for (...)
{
	if (str[i] >= 'A' && str[i] <= 'F')
}
```
代码中的数组访问用临时变量代替：
```c
for(...)
{
        char temp = str[i];
	if (temp >= 'A' && temp <= 'F')
}
```
##### 优化点4：利用移位运算代替乘除
可将*2操作用<<1代替，在计算机中，移位操作比乘除法操作更友好。
##### 优化点5：多线程，使用SIMD编程
PPT中有所涉及：
![img](https://github.com/Azzzting/homework-group-48/blob/main/Project4/img/4.png)

并给出示例：
![img](https://github.com/Azzzting/homework-group-48/blob/main/Project4/img/3.png)
##### 受到启发，具体见代码SIMD实现。

### 实验结果：
原始sm3实现：

![img](https://github.com/Azzzting/homework-group-48/blob/main/Project4/img/2.png)

优化后sm3实现：

![img](https://github.com/Azzzting/homework-group-48/blob/main/Project4/img/1.png)

最终在同等数据规模下实现约61.6%的加速。
