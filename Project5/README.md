#### 实验内容：
Impl Merkle Tree following RFC6962
#### 理论依据：
Merkle trees的主要作用是快速归纳和校验区块数据的存在性和完整性。一般意义上来讲，它是哈希大量聚集数据“块”的一种方式，它依赖于将这些数据“块”分裂成较小单位的数据块，每一个bucket块仅包含几个数据“块”，然后取每个bucket单位数据块再次进行哈希，重复同样的过程，直至剩余的哈希总数仅变为1。

通俗来说，我们可以把Merkle Tree可以看做Hash List的泛化（Hash List可以看作一种特殊的Merkle Tree，即树高为2的多叉Merkle Tree）。

在最底层，和哈希列表一样，我们把数据分成小的数据块，有相应地哈希和它对应。但是往上走，并不是直接去运算根哈希，而是把相邻的两个哈希合并成一个字符串，然后运算这个字符串的哈希，这样每两个哈希可得到一个”子哈希“。如果最底层的哈希总数是单数，那到最后必然出现一个单哈希，这种情况就直接对它进行哈希运算，所以也能得到它的子哈希。于是往上推，依然是一样的方式，可以得到数目更少的新一级哈希，最终必然形成一棵倒挂的树，到了树根的这个位置，这一代就剩下一个根哈希了，我们把它叫做 Merkle Root。

Merkle tree和Hash list的主要区别是，可以直接下载并立即验证Merkle tree的一个分支。因为可以将文件切分成小的数据块，这样如果有一块数据损坏，仅仅重新下载这个数据块就行了。如果文件非常大，那么Merkle tree和Hash list都很到，但是Merkle tree可以一次下载一个分支，然后立即验证这个分支，如果分支验证通过，就可以下载数据了。而Hash list只有下载整个hash list才能验证。
![img](https://github.com/Azzzting/homework-group-48/blob/main/Project5/img/2.png)
#### 实验思路：
在最底层，和哈希列表一样，可以把数据分成小的数据块，有相应地哈希和它对应。 当从叶子节点向上计算时，项目是将相邻的两个哈希合并成一个字符串，然后运算这个字符串的哈希，这样每两个哈希形成一个”子哈希“。 如果最底层的哈希总数是单数，那到最后必然出现一个哈希无法和其他哈希进行合并，此时直接对它进行哈希运算得到它的子哈希即可。 如此循环向上进行合并，可以得到数目更少的新一级哈希，最终必然形成一棵倒挂的树，到了根节点的位置时，只剩下一个跟哈希了。
#### 实验结果：
![img](https://github.com/Azzzting/homework-group-48/blob/main/Project5/img/1.png)
